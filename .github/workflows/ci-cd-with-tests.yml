name: Complete CI/CD Pipeline

on:
  pull_request:
    branches:
      - main
  push:
    branches:
      - main
      - dev
  workflow_dispatch:

jobs:
  build_and_test:
    runs-on: [seame] #ubuntu-latest
    outputs:
      tests_passed: ${{ steps.set_test_output.outputs.tests_passed }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Pull Jetson Nano Ubuntu Docker image
        run: docker pull jmoreiraseame/jetson-nano-ubuntu:bionic

      - name: Make test script executable
        run: chmod +x run_tests.sh

      - name: Inspect ZeroMQ installation
        run: |
          docker run --rm --platform linux/arm64 \
            -v ${{ github.workspace }}:/repo \
            -w /repo jmoreiraseame/jetson-nano-ubuntu:bionic \
            /bin/bash -c "
            echo 'Checking for libzmq library files...' && \
            find /usr -name '*zmq*' | grep -E '\.so|\.a' || echo 'No library files found' && \
            echo 'Checking for ZeroMQ headers...' && \
            find /usr -name 'zmq.h' || echo 'No zmq.h found' && \
            find /usr -name 'zmq.hpp' || echo 'No zmq.hpp found' && \
            echo 'Checking pkg-config...' && \
            pkg-config --list-all | grep zmq || echo 'ZeroMQ not found in pkg-config'
            "

      - name: Build project with tests and coverage
        run: |
          docker run --rm --platform linux/arm64 \
            -v ${{ github.workspace }}:/repo \
            -w /repo jmoreiraseame/jetson-nano-ubuntu:bionic \
            /bin/bash -c "
            # Install ZeroMQ dependencies first
            apt-get update && \
            apt-get install -y libzmq3-dev git wget tar lcov gcovr \
                             libi2c-dev joystick libjoystick-dev liblinux-dev linux-libc-dev && \
            # Install newer cppzmq for modern API support (temporary until Docker image is updated)
            cd /tmp && \
            wget https://github.com/zeromq/cppzmq/archive/v4.8.1.tar.gz && \
            tar xzf v4.8.1.tar.gz && \
            cd cppzmq-4.8.1 && \
            mkdir build && cd build && \
            cmake .. -DCPPZMQ_BUILD_TESTS=OFF && \
            make install && \
            ldconfig && \
            # Now build the project
            cd /repo && \
            # Check for required headers
            echo 'Checking for required headers:' && \
            find /usr/include -name 'joystick.h' -o -name 'i2c-dev.h' && \
            # Create dummy headers if not found
            mkdir -p /repo/Controller/mock_headers/linux && \
            if [ ! -f /usr/include/linux/joystick.h ]; then
              echo 'Creating mock joystick.h' && \
              cat > /repo/Controller/mock_headers/linux/joystick.h << 'EOF'
#ifndef LINUX_JOYSTICK_H
#define LINUX_JOYSTICK_H
#include <stdint.h>

#define JS_EVENT_BUTTON 0x01
#define JS_EVENT_AXIS   0x02
#define JS_EVENT_INIT   0x80

struct js_event {
    uint32_t time;     /* event timestamp in milliseconds */
    int16_t value;     /* value */
    uint8_t type;      /* event type */
    uint8_t number;    /* axis/button number */
};

#define JSIOCGNAME(len) _IOC(_IOC_READ, 'j', 0x13, len)

#endif /* LINUX_JOYSTICK_H */
EOF
            fi && \
            if [ ! -f /usr/include/linux/i2c-dev.h ]; then
              echo 'Creating mock i2c-dev.h' && \
              cat > /repo/Controller/mock_headers/linux/i2c-dev.h << 'EOF'
#ifndef LINUX_I2C_DEV_H
#define LINUX_I2C_DEV_H
/* Minimal header for build purposes */
#endif /* LINUX_I2C_DEV_H */
EOF
            fi && \
            # Update Controller's CMakeLists.txt to include mock headers if needed
            cat > /repo/Controller/CMakeLists.txt.new << 'EOF'
$(cat /repo/Controller/CMakeLists.txt)

# Check if we need to use mock headers
if(EXISTS \"${PROJECT_SOURCE_DIR}/mock_headers\")
    target_include_directories(Controller PRIVATE \"${PROJECT_SOURCE_DIR}/mock_headers\")
endif()
EOF
            mv /repo/Controller/CMakeLists.txt.new /repo/Controller/CMakeLists.txt && \
            mkdir -p /repo/build && \
            cd /repo/build && \
            cmake .. -DCODE_COVERAGE=ON && \
            # First build ZeroMQLib and Middleware
            make -j$(nproc) ZeroMQLib middleware && \
            echo '==== ZeroMQLib and Middleware built successfully ====' && \
            # Now try to build Controller with detailed output
            VERBOSE=1 make -j1 Controller || { \
              echo '==== Controller build failed, checking dependency errors ====' && \
              cat Controller/CMakeFiles/Controller.dir/depend.make || echo 'No dependency information' && \
              cat Controller/CMakeFiles/Controller.dir/link.txt || echo 'No link command information' && \
              find Controller/CMakeFiles/Controller.dir -name '*.o*' | wc -l && \
              find Controller/CMakeFiles/Controller.dir -name '*.o*' && \
              find Controller/CMakeFiles -name '*.log' -exec cat {} \\; && \
              grep -r error Controller/CMakeFiles && \
              echo '==== Trying alternative build approaches ====' && \
              make VERBOSE=1 Controller || echo 'Controller build failed again' && \
              exit 1; \
            } && \
            # Build the rest of the project
            make -j$(nproc) || { \
              echo '==== Full build failed, but Controller was built ====' && \
              # Continue anyway to test what we can
              true; \
            }
            "

      - name: Run tests
        id: run_tests
        continue-on-error: true
        run: |
          docker run --rm --platform linux/arm64 \
            -v ${{ github.workspace }}:/repo \
            -w /repo jmoreiraseame/jetson-nano-ubuntu:bionic \
            /bin/bash -c "
            # Ensure dependencies are installed
            apt-get update && \
            apt-get install -y libzmq3-dev lcov gcovr && \
            # The build step should have already installed cppzmq
            cd /repo/build/bin && \
            mkdir -p reports && \
            export GTEST_COLOR=1 && \
            # Run each test with XML output and collect coverage data
            for test in *_test; do
              if [ -x \"\$test\" ]; then
                echo \"Running \$test...\"
                mkdir -p \"reports/\$test\"
                # Run with coverage instrumentation
                GCOV_PREFIX=/repo/build GCOV_PREFIX_STRIP=2 ./\$test --gtest_output=xml:\"reports/\$test/results.xml\" || echo \"Test \$test failed with exit code \$?\"
              fi
            done && \
            # Generate initial coverage data files
            cd /repo/build && \
            find . -name '*.gcda' -o -name '*.gcno' | sort
            "
          # We don't exit with failure here - we'll analyze test results separately

      - name: Set tests passed output
        id: set_test_output
        run: |
          # Check if any XML files contain failures
          FAILURE_COUNT=$(grep -r "<failure" --include="*.xml" build/bin/reports | wc -l)
          if [ "$FAILURE_COUNT" -gt 0 ]; then
            echo "tests_passed=false" >> $GITHUB_OUTPUT
            echo "Tests failed: $FAILURE_COUNT failures found"
          else
            echo "tests_passed=true" >> $GITHUB_OUTPUT
            echo "All tests passed"
          fi

      - name: Generate coverage report
        run: |
          docker run --rm --platform linux/arm64 \
            -v ${{ github.workspace }}:/repo \
            -w /repo jmoreiraseame/jetson-nano-ubuntu:bionic \
            /bin/bash -c "
            # Ensure dependencies are installed
            apt-get update && \
            apt-get install -y libzmq3-dev lcov gcovr && \
            # Run tests to generate coverage data
            cd /repo/build && \
            export GTEST_COLOR=1 && \

            # Print CMake variables to see the coverage target definition
            cmake --build . --target help | grep coverage || echo 'No coverage target found' && \

            # Try to run the coverage target
            cmake --build . --target coverage || true && \

            # Debug - check if the coverage files exist
            echo 'Checking coverage files:' && \
            find /repo/build -name 'coverage' -type d || true && \
            find /repo/build -name '*.info' || true && \

            # Generate coverage report manually
            echo 'Generating coverage report manually...' && \
            cd /repo && \
            mkdir -p /repo/build/coverage/html && \
            lcov --capture --directory /repo/build --output-file /repo/build/coverage/coverage.info && \
            lcov --remove /repo/build/coverage/coverage.info '/usr/*' --output-file /repo/build/coverage/coverage.info && \
            genhtml /repo/build/coverage/coverage.info --output-directory /repo/build/coverage/html && \

            # Verify the coverage report exists
            ls -la /repo/build/coverage/html || echo 'Coverage report directory still not found'
            "

      - name: Upload coverage report
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: |
            build/coverage/html
            build/coverage/coverage.info
          if-no-files-found: warn
        if: always()

      - name: Upload test results
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: build/bin/reports
        if: always()

      - name: Publish test report
        uses: mikepenz/action-junit-report@v3
        if: always()
        with:
          report_paths: 'build/bin/reports/**/results.xml'
          fail_on_failure: false

      - name: Generate coverage badges
        uses: codecov/codecov-action@v3
        if: always()
        with:
          directory: ./build/coverage
          flags: unittests
          name: codecov-umbrella
          fail_ci_if_error: false
          verbose: true

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifact
          path: build/bin

  deploy:
    runs-on: [seame]
    needs: build_and_test
    if: needs.build_and_test.outputs.tests_passed == 'true' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev')

    steps:
      - name: Ensure target directory exists
        run: |
          mkdir -p ./team06/bin \
          && rm -rf ./bin/*

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifact
          path: ./bin

      - name: Ship binary to Jetson
        run: |
          sshpass -p "${{ secrets.JETSON_PASSWORD }}" \
          scp -r ./bin \
          team06@10.21.221.56:/home/team06/

      - name: Give binaries permission to execute
        run: |
          sshpass -p "${{ secrets.JETSON_PASSWORD }}" \
          ssh team06@10.21.221.56 'chmod +x /home/team06/bin/*'

  notify:
    runs-on: [seame]
    needs: [build_and_test, deploy]
    if: always()
    steps:
      - name: Pipeline Status
        run: |
          if [[ "${{ needs.build_and_test.result }}" == "success" && "${{ needs.deploy.result }}" == "success" ]]; then
            echo "Pipeline completed successfully! ✅"
          elif [[ "${{ needs.build_and_test.result }}" == "success" && "${{ needs.deploy.result }}" == "skipped" ]]; then
            echo "Build and tests passed, but deployment was skipped (tests may have failed or not on main/dev branch) ⚠️"
          elif [[ "${{ needs.build_and_test.result }}" == "success" && "${{ needs.deploy.result }}" == "failure" ]]; then
            echo "Build and tests passed, but deployment failed ❌"
          else
            echo "Build or tests failed ❌"
          fi
