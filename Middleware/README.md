# JetRacer Middleware

## Overview
JetRacer Middleware is a C++ application designed to bridge the sensors on JetRacer with the [Cluster Display](https://github.com/SEAME-pt/Team06-SEAME-DES_Instrument-Cluster/tree/feature/clusterdisplay/ClusterDisplay). It provides a robust interface for managing sensor data and communicating it efficiently to the display.

The middleware leverages a modular design, utilizing the `ISensor.hpp` interface to create instances for each sensor, ensuring scalability and maintainability.

---

## Features
- **Sensor Integration**:
  - Currently supports speed measurement through the [CanReader](https://github.com/SEAME-pt/Team06-SEAME-DES_Instrument-Cluster/tree/feature/can) class, enabling communication via the CAN bus.
  - Reads battery level using the [BatteryReader](https://github.com/SEAME-pt/Team06-SEAME-DES_Instrument-Cluster/tree/feature/battery) class.
- **Multithreaded Operation**:
  - Uses two threads running at different frequencies:
    - **High-frequency thread**: Handles critical information, such as speed data.
    - **Low-frequency thread**: Manages non-critical information, such as battery status.
- **Communication with Cluster Display**:
  - Implements a ZeroMQ Pub-Sub pattern for seamless data transmission via TCP sockets.

---

## Design Highlights
- **Scalable Sensor Architecture**:
  - Built around the `ISensor.hpp` interface, allowing easy addition of new sensors.
- **Threaded Execution**:
  - Ensures timely updates for critical data while optimizing resource usage for non-critical updates.
- **Reliable Communication**:
  - Uses ZeroMQ to guarantee efficient and reliable data exchange between the middleware and the Cluster Display.

---

## How It Works
1. **Sensor Initialization**:
   - Sensors are instantiated through the `ISensor.hpp` interface.
2. **Data Acquisition**:
   - Critical data (e.g., speed) is read at a high frequency.
   - Non-critical data (e.g., battery level) is read at a lower frequency.
3. **Data Transmission**:
   - Sensor values are published to the Cluster Display via ZeroMQ's Pub-Sub mechanism over TCP.

---

# Back Motors Control

This document describes the functions responsible for controlling the rear motors, using the PCA9685 motor controller.

## Function `init_motors`

The `init_motors` function is responsible for initializing the motor controller. It performs the following steps:

### 1. **Motor Controller Configuration**: The function configures the register `0x00` with the value `0x20` to initialize the device.

`0x00` in `PCA9685` is `MODE1`, which controls the basic operation modes of the device, such as auto-increment, sleep mode, etc.
`0x7F` is represented as `0111 1111`.

### 2. **60Hz Frequency Configuration**:
    - The prescaler value is calculated using the formula:

$$
\text{{prescaler}} = \left\lfloor \frac{{25000000.0}}{{4096.0 \times 60}} - 1 \right\rfloor
$$

    The prescaler value defines the PWM signal frequency generated by the PCA9685.

`oldMode = readByteData(_fdMotor, 0x00)`
Captures the current state of MODE1 before changing it, so that it can be temporarily modified and restored later if necessary.

`newMode = (oldMode & 0x7F) | 0x10`
Creates a new configuration for the `MODE1` register:
   - `oldMode & 0x7F`: This operation clears the most significant bit (MSB) of the read value, which corresponds to the PCA9685's restart (RESTART) bit. This is important because the RESTART bit should be disabled while configuring the prescaler.
   - `| 0x10`: Sets the sleep (SLEEP) bit in the `MODE1` register. Sleep mode is required for configuring the prescaler, as required by PCA9685.

### 3. **New Mode and Frequency Configuration**:
    - The device mode is changed to ensure it operates at the correct frequency, and the prescaler value is configured in register `0xFE`.

- `writeByteData(_fdMotor, 0x00, newMode)`: Putting the PCA9685 into sleep mode is mandatory before changing the prescaler value in register 0xFE. Without this, writing to the prescaler will be ignored.
- `writeByteData(_fdMotor, 0xFE, preScale)`: Writes the calculated `preScale` value to the PCA9685's register 0xFE. Writing to this register is only allowed when the device is in sleep mode, which is why the previous step puts the PCA9685 into sleep mode.
- `writeByteData(_fdMotor, 0x00, oldMode)`: Restores the original `oldMode` value in register `0x00` (MODE1). After configuring the prescaler, the PCA9685 should be taken out of sleep mode to start normal operation.

### 4. **Auto-Increment Activation**:
    - Auto-increment is enabled in PCA9685 to ensure that multiple channel controls are handled sequentially.
- `writeByteData(_fdMotor, 0x00, oldMode | 0xa1)`
    - `0xA1 = 1010 0001`
      - `Bit 7 (RESTART)`: 1  Activates the PCA9685 restart. This forces the controller to restart the PWM cycle after exiting sleep mode.
      - `Bit 5 (EXTCLK)`: 0  Sets the PCA9685 to use the internal 25 MHz clock, rather than an external clock.
      - `Bit 4 (SLEEP)`: 0  Ensures sleep mode is disabled, allowing normal operation.
      - `Bit 2 (AUTO-INCREMENT)`: 1  Activates auto-increment mode, which facilitates sequential writes to multiple registers.
---

## Function `Set Motor PWM`

### `1. writeByteData(_fdMotor, 0x06 + 4 * channel, 0)`;

  - Purpose: Write the value 0 to the register that defines when the PWM signal should be activated for the specified channel.
  - Technical Details:
        - `0x06`: The base address of the register LEDn_ON_L, which defines the PWM activation value for channel n.
        - `4 * channel`: Each channel uses 4 consecutive registers (two for activation and two for deactivation).

### `2. writeByteData(_fdMotor, 0x07 + 4 * channel, 0)`;

  - Purpose: Write the value 0 to the LEDn_ON_H register.
  - Technical Details:
    - 0x07 is the address of the LEDn_ON_H register, which defines the most significant bits of the PWM activation value for channel n.

### `3. writeByteData(_fdMotor, 0x08 + 4 * channel, value & 0xFF)`;

  - Purpose: Write the least significant 8 bits of the PWM deactivation value for the channel.
  - Technical Details:
      - `0x08` is the address of the LEDn_OFF_L register, which defines the least significant bits of the PWM deactivation value for channel n.
      - `value & 0xFF`: Performs an AND operation with 0xFF to extract the least significant 8 bits of the value.

### `4. writeByteData(_fdMotor, 0x09 + 4 * channel, value >> 8)`;

  - Purpose: Write the most significant 8 bits of the PWM deactivation value for the channel.
  - Technical Details:
      - `0x09` is the address of the LEDn_OFF_H register, which defines the most significant bits of the PWM deactivation value for channel n.
      - `value >> 8`: Performs a right shift of 8 bits on the value to extract the most significant bits.


#### `LEDn_OFF` is split into two bytes:

-     LEDn_OFF_L (Low Byte): Stores the least significant 8 bits.
-     LEDn_OFF_H (High Byte): Stores the most significant 8 bits.

#### `LEDn_ON` is composed of two bytes:

-     LEDn_ON_L (Low Byte): Contains the least significant 8 bits.
-     LEDn_ON_H (High Byte): Contains the most significant 8 bits.

#### `Example of Operation`:

- If `value = 2048` and `channel = 0`:
  - `writeByteData(_fdMotor, 0x06, 0)` → Activation at the start of the cycle.
  - `writeByteData(_fdMotor, 0x07, 0)` → Most significant bits of activation.
  - `writeByteData(_fdMotor, 0x08, 2048 & 0xFF)` → Writes 0x00 to the OFF_L register.
  - `writeByteData(_fdMotor, 0x09, 2048 >> 8)` → Writes 0x08 to the OFF_H register.

Result: The PWM activates at the start of the cycle and deactivates at tick 2048.

## Function `Set Motor PWM`

### This line converts the speed (as a percentage) into a corresponding PWM value, ranging from 0 to 4095:
$$
\text{pwmValue} = \left\lfloor \frac{\lvert \text{speed} \rvert}{100} \times 4095 \right\rfloor
$$

### Controlling the motors to move forward:

Front motors:
- Channel 0 (IN1): Receives the PWM value (`pwmValue`), indicating that this motor should rotate in one direction.
- Channel 1 (IN2): Receives PWM 0, disabling reverse rotation.
- Channel 2 (ENA): Controls the motor's activation. Also receives the `pwmValue`.

Rear motors:

- Channel 5 (IN3): Receives the PWM value (`pwmValue`), indicating the direction.
- Channel 6 (IN4): Receives PWM 0, disabling reverse rotation.
- Channel 7 (ENB): Controls the activation of the rear motor. Also receives the `pwmValue`.

---
---
---

# FServo Class

## Overview
The `FServo` class is designed to control a servo motor using I2C communication and the PCA9685 controller. This controller is widely used for efficiently managing multiple servo motors, offering precise control over the servo's movement.

## Purpose

1. **Initialize and configure the servo motor**: The class performs the initial configuration of the PCA9685 controller, setting frequencies and modes required for proper servo operation.
2. **Set the steering angle**: Based on calculations using the desired angle (from -90° to +90°), the class adjusts the PWM to position the servo at the correct angle.
3. **Manage I2C communication**: Directly controls the PCA9685 registers using I2C commands to read and write data.

## General Structure

### INIT_SERVO:
  - **Reset PCA9685**:
    - `0x00` --> This is "MODE1" in the PCA9685, which is one of the chip's control registers. It is responsible for setting modes such as the operation mode and reset.
    - `0x06` --> This is used to reset the PCA9685. When the PCA9685 receives this value in MODE1, it performs an internal reset.
  - **Setup servo control**
    - `0x10` --> Configures the control register so that the chip not only resets but also enters a proper mode for PWM control, essential for servo control.

  - **Configure MODE2**
    - `0x01` --> This is MODE2 of the PCA9685, which defines how the controller behaves with PWM outputs.
    - `0x04` --> Configures the PCA9685 output mode, activating "Totem pole" mode for the outputs, meaning they can both source and sink current (to control the servo more efficiently).
  - **Enable auto-increment**
    - `0x20` --> Activates auto-increment for write operations. This way, the PCA9685 automatically writes to consecutive channels without needing to specify each channel’s address.
  - **Set frequency (~50Hz)**
    - `0xFE` --> This is the frequency oscillation register (PRESCALE). It adjusts the frequency of the PCA9685 controller.
    - `0x79` --> The value 0x79 (or 121 in decimal) was calculated based on the PCA9685 prescaler formula to generate a signal of approximately 50 Hz. The PWM frequency in the PCA9685 is determined by the equation:

$$
F_{PWM} = \frac{PCA9685_{freq}}{4096 \times (prescaler + 1)}
$$

---

### Set Servo PWM
Instructions used to configure the "on" and "off" values to control each servo channel on the PCA9685 controller.
  - `Register 0x06 + 4 * channel`: The control register address for the servo channel is based on the channel number. Each servo channel in the PCA9685 occupies 4 consecutive bytes. The first byte is the "on" (initial value), the second byte is the 8 most significant bits of "on," the third byte is the "off," and the fourth byte is the 8 most significant bits of "off."
  - `on_value & 0xFF`:
    The on_value is a 16-bit value (16 bits define the start and end of the PWM pulse). The & 0xFF is a bitwise mask that extracts the 8 least significant bits from the on_value. In other words, it picks the first 8 bits of the on_value.
  - `Register 0x07 + 4 * channel`: This is the second byte of the "on" value.
  - `on_value >> 8`: The `>>` operator performs a right shift. This shifts the 8 most significant bits of the on_value to the 8 least significant bits. In other words, it gets the most significant part of the on_value.
  - `Register 0x08 + 4 * channel`: This is the first byte of the "off" value.
  - `Register 0x09 + 4 * channel`: This is the second byte of the "off" value.

---

### SET STEERING

  - #### PWM Calculation for Negative Angle

When the angle is negative, the PWM calculation is given by:

$$
pwm = \text{{servoCenterPwm}} + \left( \frac{{\text{{angle}}}}{{\text{{maxAngle}}}} \right) \times (\text{{servoCenterPwm}} - \text{{servoLeftPwm}})
$$

Where:
- `servoCenterPwm` is the PWM value for the center position (320).
- `angle` is the desired angle (in this case, negative).
- `maxAngle` is the maximum rotation angle (usually 90 degrees).
- `servoLeftPwm` is the PWM value for the left limit of the servo (320 - 150).

---

#### PWM Calculation for Positive Angle

When the angle is positive, the PWM calculation is given by:

$$
pwm = \text{{servoCenterPwm}} + \left( \frac{{\text{{angle}}}}{{\text{{maxAngle}}}} \right) \times (\text{{servoRightPwm}} - \text{{servoCenterPwm}})
$$

Where:
- `servoRightPwm` is the PWM value for the right limit of the servo (320 + 150).

---

- **Public Methods**:
  - Constructor and destructor to open and close the I2C bus connection.
  - Functions to initialize the servo (`init_servo`), configure the PWM (`setServoPwm`), and adjust the steering angle (`set_steering`).

- **Private Helper Methods**:
  - Functions for reading and writing data to the PCA9685 controller.

### General Operation Flow
1. **Initialization**: When an object of the class is created, the constructor opens the connection to the I2C device and sets the address of the PCA9685 controller.
2. **Servo Configuration**: The `init_servo` method configures the PCA9685 to operate at the correct frequency and sets the required modes.
3. **Angle Control**: The `set_steering` method allows adjusting the servo angle by converting the desired angle into appropriate PWM values and sending them to the controller.

---
---
---


